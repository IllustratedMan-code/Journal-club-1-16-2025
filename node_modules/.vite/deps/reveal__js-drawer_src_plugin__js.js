import "./chunk-T2T6Q22Z.js";

// node_modules/reveal.js-drawer/src/keys.js
var keys_default = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pausebreak: 19,
  capslock: 20,
  esc: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  leftarrow: 37,
  uparrow: 38,
  rightarrow: 39,
  downarrow: 40,
  insert: 45,
  delete: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  leftwindowkey: 91,
  rightwindowkey: 92,
  selectkey: 93,
  numpad0: 96,
  numpad1: 97,
  numpad2: 98,
  numpad3: 99,
  numpad4: 100,
  numpad5: 101,
  numpad6: 102,
  numpad7: 103,
  numpad8: 104,
  numpad9: 105,
  multiply: 106,
  add: 107,
  subtract: 109,
  decimalpoint: 110,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrolllock: 145,
  semicolon: 186,
  equalsign: 187,
  comma: 188,
  dash: 189,
  period: 190,
  forwardslash: 191,
  graveaccent: 192,
  openbracket: 219,
  backslash: 220,
  closebracket: 221,
  singlequote: 222
};

// node_modules/reveal.js-drawer/src/controlPanel.js
var defaultColorSetting = {
  parentElement: null,
  color: "red",
  selected: false,
  onClick: null
};
var defaultContainerSetting = {
  parentElement: null,
  colors: ["red", "blue", "green", "yellow"],
  onColorChange: null
};
var colorSelector = ({
  parentElement,
  color,
  selected,
  onClick
} = defaultColorSetting) => {
  const settings = {
    color,
    selected
  };
  if (parentElement == null) {
    console.error("Please provide parent element for color selector");
  }
  const onSelect = function() {
    if (onClick != null) {
      onClick(settings.color);
    }
    settings.selected = true;
  };
  const unSelect = () => {
    selected.settings = false;
  };
  settings.element = document.createElement("div");
  settings.element.className = "revealjs-drawer-color_picker";
  settings.element.style.backgroundColor = color;
  settings.element.addEventListener("click", onSelect);
  parentElement.append(settings.element);
  return {
    unSelect,
    select: onSelect
  };
};
var penIconElement = ({ parentElement = null }) => {
  if (parentElement == null) {
    console.error("Please provide parent element for color container");
  }
  const penIcon = document.createElement("div");
  penIcon.className = "revealjs-drawer-pen_icon";
  parentElement.append(penIcon);
  const changeColor = (newColor) => {
    penIcon.style.backgroundColor = newColor;
  };
  return {
    changeColor,
    disable: () => {
      penIcon.classList.add("disabled");
    },
    enable: () => {
      penIcon.classList.remove("disabled");
    }
  };
};
var colorContainer = ({
  parentElement,
  colors,
  onColorChange
} = defaultContainerSetting) => {
  if (parentElement == null) {
    console.error("Please provide parent element for color container");
  }
  const penElement = penIconElement({ parentElement });
  const iconContainer = document.createElement("div");
  iconContainer.className = "revealjs-drawer-color_container";
  parentElement.append(iconContainer);
  const changeSelectedColor = (newColor) => {
    settings.selectColor = newColor;
    if (onColorChange != null) {
      onColorChange(newColor);
    }
    penElement.changeColor(newColor);
  };
  const settings = {
    selectedColor: colors[0],
    colors: colors.reduce((acc, color) => {
      acc[color] = colorSelector({
        parentElement: iconContainer,
        color,
        selected: color === colors[0],
        onClick: changeSelectedColor
      });
      return acc;
    }, {})
  };
  penElement.changeColor(settings.selectedColor);
  const selectColor = (color) => {
    settings.colors[color].select();
  };
  return {
    selectColor,
    disablePen: () => {
      penElement.disable();
    },
    enablePen: () => {
      penElement.enable();
    }
  };
};
var controlPanel_default = colorContainer;

// node_modules/reveal.js-drawer/src/plugin.js
import "/home/nixos/Documents/Journal-club-1-16-2025/node_modules/reveal.js-drawer/src/styles.css";
function insertAfter(newNode, referenceNode) {
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
var Drawer = () => {
  let options = {};
  let isPointerActive = false;
  let boards = {};
  let cursorListener = null;
  let mousedownListener = null;
  let mouseupListener = null;
  let drawerElement = null;
  let drawerElementContext = null;
  let drawerContainerElement = null;
  let colorsBoard = null;
  let eventDispatcher = null;
  let currentBoard = {
    drawerElement: null,
    drawerElementContext: null,
    paths: []
  };
  let isBoardVisible = false;
  let isCtrlPressed = false;
  const mouse = {
    x: 0,
    y: 0,
    prevX: 0,
    prevY: 0,
    isVisible: false
  };
  function getKeyCode(key) {
    return keys_default[key];
  }
  function initOptions(config) {
    options = config.drawer || {};
    if (options.toggleDrawKey == null) {
      options.toggleDrawKey = "d";
    } else {
      options.toggleDrawKey = options.toggleDrawKey.toLowerCase();
    }
    if (options.toggleBoardKey == null) {
      options.toggleBoardKey = "t";
    } else {
      options.toggleBoardKey = options.toggleBoardKey.toLowerCase();
    }
    if (options.pathSize == null || typeof options.pathSize !== "number") {
      options.pathSize = 12;
    }
    if (!Array.isArray(options.colors) || options.colors.length === 0) {
      options.colors = ["#fa1e0e", "#8ac926", "#1982c4", "#ffca3a"];
    }
    if (options.color == null || typeof options.color !== "string") {
      options.color = options.colors[0];
    }
    options.drawKeyCode = getKeyCode(options.toggleDrawKey);
    options.boradKeyCode = getKeyCode(options.toggleBoardKey);
  }
  function draw() {
    mouse.dirty = false;
    mouse.prevX = mouse.x;
    mouse.prevY = mouse.y;
    if (currentBoard.paths.length === 0) {
      return false;
    }
    const currentPath = currentBoard.paths[currentBoard.paths.length - 1];
    currentBoard.drawerElementContext.fillStyle = currentPath.color;
    currentBoard.drawerElementContext.strokeStyle = currentPath.color;
    currentBoard.drawerElementContext.lineWidth = currentPath.pathSize;
    currentBoard.drawerElementContext.stroke(currentPath);
  }
  function redraw() {
    currentBoard.drawerElementContext.clearRect(0, 0, currentBoard.drawerElement.width, currentBoard.drawerElement.height);
    for (const pathPath of currentBoard.paths) {
      currentBoard.drawerElementContext.fillStyle = pathPath.color;
      currentBoard.drawerElementContext.strokeStyle = pathPath.color;
      currentBoard.drawerElementContext.lineWidth = pathPath.pathSize;
      currentBoard.drawerElementContext.stroke(pathPath);
    }
  }
  function trackCursor(event) {
    if (event.buttons === 1) {
      const rect = currentBoard.drawerElement.getBoundingClientRect();
      currentBoard.paths[currentBoard.paths.length - 1].lineTo(event.clientX - rect.left, event.clientY - rect.top);
    }
    mouse.x = event.pageX;
    mouse.y = event.pageY;
    if (!mouse.dirty && isBoardVisible && event.buttons === 1) {
      mouse.dirty = true;
      requestAnimationFrame(draw);
    }
  }
  function disableDrawing(event) {
    draw();
    currentBoard.paths.push(new Path2D());
    currentBoard.paths[currentBoard.paths.length - 1].color = options.color;
    currentBoard.paths[currentBoard.paths.length - 1].pathSize = options.pathSize;
  }
  function registerCursor() {
    cursorListener = document.addEventListener("mousemove", trackCursor);
    mouseupListener = document.addEventListener("mouseup", disableDrawing);
    mouse.isVisible = true;
    colorsBoard.enablePen();
    drawerContainerElement.classList.remove("disabled");
  }
  function unregisterEventListener() {
    document.removeEventListener("mousemove", trackCursor);
    document.removeEventListener("mouseup", disableDrawing);
    cursorListener = null;
    mouse.isVisible = false;
    colorsBoard.disablePen();
    drawerContainerElement.classList.add("disabled");
    requestAnimationFrame(draw);
  }
  function initBoardElement(slideId) {
    hideCurrentBoard();
    drawerElement = function() {
      const n = document.createElement("canvas");
      n.className = "revealjs-drawer_canvas";
      const containerElement = document.querySelector(".revealjs-drawer");
      containerElement.appendChild(n);
      return n;
    }();
    drawerElementContext = drawerElement.getContext("2d");
    drawerElementContext.canvas.width = window.innerWidth;
    drawerElementContext.canvas.height = window.innerHeight;
    drawerElementContext.imageSmoothingEnabled = true;
    boards[slideId] = {
      drawerElement,
      drawerElementContext,
      paths: []
    };
    if (currentBoard.drawerElement) {
    }
    currentBoard = boards[slideId];
    disableDrawing();
  }
  const changeColor = (newColor) => {
    options.color = newColor;
    if (eventDispatcher != null) {
      eventDispatcher({
        type: "pointerColorChange",
        data: {
          color: newColor
        }
      });
    }
    disableDrawing();
  };
  function initCanvasContainer(deck) {
    eventDispatcher = deck.dispatchEvent;
    drawerContainerElement = function() {
      const n = document.createElement("div");
      n.className = "revealjs-drawer";
      n.style.display = "none";
      const menu = document.createElement("div");
      menu.className = "revealjs-drawer-menu";
      colorsBoard = controlPanel_default({
        parentElement: menu,
        colors: options.colors,
        onColorChange: changeColor
      });
      n.append(menu);
      const slidesElement = document.querySelector(".slides");
      insertAfter(n, slidesElement);
      return n;
    }();
  }
  function togglePointerActive() {
    isPointerActive = !isPointerActive;
    if (isPointerActive) {
      registerCursor();
    } else {
      unregisterEventListener();
    }
  }
  function removeLastPath(e) {
    if (e.ctrlKey && e.key === "z") {
      const currPath = currentBoard.paths.pop();
      currentBoard.paths.pop();
      currentBoard.paths.push(currPath);
      requestAnimationFrame(redraw);
    }
  }
  function changeColorManually(e) {
    const colorKeys = options.colors.map((color, idx) => String(idx + 1));
    if (colorKeys.includes(e.key)) {
      colorsBoard.selectColor(options.colors[Number(e.key) - 1]);
    }
  }
  function registerKeys() {
    document.addEventListener("keydown", removeLastPath);
    document.addEventListener("keydown", changeColorManually);
  }
  function unregisterKeys() {
    document.removeEventListener("keydown", removeLastPath);
    document.removeEventListener("keydown", changeColorManually);
  }
  function toggleBoardVisibility() {
    drawerContainerElement.style.display = drawerContainerElement.style.display === "none" ? "block" : "none";
    isPointerActive = drawerContainerElement.style.display !== "none";
    if (isPointerActive) {
      registerKeys();
      registerCursor();
      isBoardVisible = true;
      if (eventDispatcher != null) {
        eventDispatcher({
          type: "pointerColorChange",
          data: {
            color: options.color
          }
        });
      }
    } else {
      unregisterKeys();
      unregisterEventListener();
      isBoardVisible = false;
      if (eventDispatcher != null) {
        eventDispatcher({
          type: "pointerColorChange",
          data: {
            color: null
          }
        });
      }
    }
  }
  function changeBoardToSlide(slideId) {
    hideCurrentBoard();
    currentBoard = boards[slideId];
    currentBoard.drawerElement.style.display = "block";
  }
  function hideCurrentBoard() {
    if (currentBoard.drawerElement) {
      currentBoard.drawerElement.style.display = "none";
    }
  }
  return {
    id: "drawer",
    init: (deck) => {
      initOptions(deck.getConfig());
      initCanvasContainer(deck);
      Reveal.on("slidechanged", (event) => {
        const slideId = `slide-${event.indexh}-${event.indexv}`;
        if (boards[slideId]) {
          changeBoardToSlide(slideId);
        } else {
          initBoardElement(slideId);
        }
      });
      Reveal.on("ready", (event) => {
        const slideId = `slide-${event.indexh}-${event.indexv}`;
        if (boards[slideId]) {
          changeBoardToSlide(slideId);
        } else {
          initBoardElement(slideId);
        }
      });
      deck.addKeyBinding({ keyCode: options.drawKeyCode, key: options.toggleDrawKey }, () => {
        togglePointerActive();
      });
      deck.addKeyBinding({ keyCode: options.boradKeyCode, key: options.toggleBoardKey }, () => {
        toggleBoardVisibility();
      });
    }
  };
};
var plugin_default = Drawer;

// dep:reveal__js-drawer_src_plugin__js
var reveal_js_drawer_src_plugin_js_default = plugin_default;
export {
  reveal_js_drawer_src_plugin_js_default as default
};
//# sourceMappingURL=reveal__js-drawer_src_plugin__js.js.map
